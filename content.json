[{"title":"javascript对原型的理解","date":"2017-05-26T10:02:50.000Z","path":"2017/05/26/my-article2/","text":"1.什么是原型 在构造函数创建出来的时候，系统会默认的帮构造函数创建并关联一个神秘的对象，这个对象就是原型，原型默认的是一个空的对象。 2.原型的作用 原型中的属性和方法，可以被使用该构造函数创建出来的对象所使用。 3.如何访问构造函数中的原型 构造函数.prototype 4.如何给原型对象添加属性和方法 使用对象的动态特性 5.原型链 对象的原型指向原型对象，形成原型链 //constructor: 原型对象内的一个属性，指向该原型对象相关联的构造函数 //\\__proto__:原型对象对象中的属性,可以使用 对象.__proto__ 去访问原型对象 &lt;script&gt; // 动物 --》 人 --》老师 --》坏老师 function Animal(){ this.gender = &quot;male&quot;; } Human.prototype = new Animal(); Human.prototype.constructor = Human; function Human(){ this.actionWay = &quot;走路&quot;; } Teacher.prototype = new Human(); Teacher.prototype.constructor = Teacher; function Teacher(){ this.skill = &quot;教书&quot;; } BadTeacher.prototype = new Teacher(); BadTeacher.prototype.constructor = BadTeacher; function BadTeacher(){ this.name = &quot;chris&quot;; } var t = new BadTeacher(); console.log(t); console.log(t.__proto__); console.log(t.__proto__.__proto__); console.log(t.__proto__.__proto__.__proto__); console.log(t.__proto__.__proto__.__proto__.__proto__); // object console.log(t.__proto__.__proto__.__proto__.__proto__.__proto__); // 对象的原型还是一个对象 所以是Object 不是null console.log(t.__proto__.__proto__.__proto__.__proto__.__proto__.__proto__); // null &lt;/script&gt; 结果： 总结： 当使用对象去访问属性和方法的时候，会首先在对象自己内部进行查找，如果找到了，就直接使用。如果没有找到，就去原型中查找，查找到之后，使用。如果原型中还没有， 如果是属性，就是undefined，如果是方法，就报错。 // 定义构造函数 function Person(name, status) { this.name = name; this.status = status; this.act = function () { console.log(&quot;演戏&quot;); }; this.exercise = function () { console.log(&quot;就不强身健体，就要保卫祖国&quot;); } } // 初始化 创建构造函数 var p = new Person(&quot;xyz&quot;,&quot;single&quot;); // 添加原型方法 Person.prototype.exercise = function () { console.log(&quot;强身健体，保卫祖国&quot;); } // 该构造函数创建出来的对象访问原型方法 p.exercise(); console.log(Person.prototype); // Object console.log(p.prototype); // undefined","tags":[]},{"title":"简单认识闭包","date":"2017-05-25T08:06:48.000Z","path":"2017/05/25/new-article/","text":"1.什么是闭包 一个具有封闭的对外不公开的，包裹结构，或空间，js中的闭包就是函数。 2.闭包原理 闭包的原理就是作用域访问原则，上级作用域无法直接访问下级作用域中的变量。 3.闭包要解决什么问题？ 闭包内的数据不允许外界访问，要解决的问题就是间接访问该数据。 4. 使用闭包获取多个数据function foo(){ var name = &apos;张国荣&apos;; var age = 18; return function(){ return name + &quot;:&quot; + age; } } var getName = foo(); console.log(getName()); 或者返回数组形式： function foo(){ var name = &apos;张国荣&apos;; var age = 18; return [ function(){ return name; }, function(){ return age; } ] } var getName = foo(); console.log(getName[0]()); console.log(getName[1]()); 或者使用对象获取： function foo(){ var name = &apos;张国荣&apos;; var age = 18; return { getName:function(){ return name; }, getAge:function(){ return age; } } } var obj = foo(); console.log(obj.getName()); console.log(obj.getAge()); 5.使用对象返回多个方法来获取并设置值function foo(){ var name = &apos;hehe&apos;; var gender = &apos;male&apos;; return { getName:function(){ return name; }, setName:function(value){ name = value; return name; }, getGender:function(){ return gender; }, setSpeed:function(value){ speed = value; return speed; } } } var obj = foo(); console.log(obj.getName()); console.log(obj.getGender()); obj.setName(&quot;xixi&quot;); console.log(obj.getName()); 6.闭包的作用 作用：1 可以通过闭包返回的函数或者方法，来修改函数内部的数据2 创建一个私有的空间，保护数据3 外部想要访问数据，只能通过函数提供的方法4 在提供的方法中，我们可以设置一些校验逻辑，让数据变得更加安全 function foo(){ var name = &quot;潘明&quot;; var badLevel = -1000000000000000000000000000000000; return { getName: function () { return name; }, setName: function (value) { name = value; return name; }, getBadLevel:function(){ return badLevel; }, setBadLevel:function (value) { //在函数外部想要修改数据 //只能通过函数内部的方法 //我们可以在函数内部定义的这个方法里 //设置安全措施，校验之类的操作 //可以保证系统的安全性和稳定性 if(value &gt; 0 ){ throw &quot;你敢说我坏！！！&quot;; } badLevel = value; return badLevel; } } }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]